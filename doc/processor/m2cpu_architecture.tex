\documentclass[a4paper,12pt]{article}

\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage[parfill]{parskip}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{pdflscape}
\usepackage{graphicx}
\usepackage{wrapfig}

\newcommand{\mt}{M2CPU}
\newcommand{\mi}{M2 instruction set}
\newcommand{\ma}{M2 architecture}
\newcommand{\inum}{75}
\newcommand{\ibusnum}{42}

\newcommand{\Ar}{\texttt{A}}
\newcommand{\Gr}{\texttt{G}}
\newcommand{\Hr}{\texttt{H}}
\newcommand{\Xr}{\texttt{X}}
\newcommand{\Yr}{\texttt{Y}}
\newcommand{\Sr}{\texttt{S}}
\newcommand{\SP}{\texttt{SP}}
\newcommand{\PC}{\texttt{PC}}
\newcommand{\IR}{\texttt{IR}}

\newcommand{\Se}{\texttt{SETUP}}
\newcommand{\Fo}{\texttt{FETCH\_1}}
\newcommand{\Ft}{\texttt{FETCH\_2}}
\newcommand{\Lo}{\texttt{LOAD\_IR}}
\newcommand{\Ex}{\texttt{EXEC}}
\newcommand{\In}{\texttt{INCPC}}

\title{M2 Architecture And Implementation}
\author{Zakary Nafziger}
\date{15 December 2017}

\begin{document}

\maketitle
\pagenumbering{gobble}
\newpage

\tableofcontents
\pagenumbering{roman}
\newpage

\listoftables
\listoffigures
\newpage

\pagenumbering{arabic}

\section{Introduction}
The \mt{} is a simple subscalar 8-bit processor that implements the \inum{} 
instruction \mi{}. The \mt{} and \mi{} were designed and implemented by the author
as a personal hobby project. The \ma{} is intended to be as simple as possible 
while still being interesting. Some basic information: 
\par

\begin{itemize}
\item 8-bit data and ALU buses
\item 16-bit address bus; 64KB of addressable memory
\item 256B zero-page stack
\item \inum{} instructions
\item implemented in VHDL on a MAX10 based development board
\end{itemize}

This document describes the \mt{}. The \mt{} is only one part of a larger 
project, the M2 computer. As of this writing the other major components of the
M2 computer project are an assembler and VGA video system. The assembler and 
video system are documented separately. 
\par

\subsection{Terminology}
Throughout this document the terms \mt{}, \mi{}, and \ma{} will be used. \mt{} 
refers to the VHDL processor that implements the \mi{}. The \mi{} is the set of
\inum{} instructions that make up the M2 assembly language. The \ma{} refers to the
combination of a processor and instruction set that implement the M2 assembly 
language. The \mt{} is therefore an implementation of the \ma{}, since it 
supports the complete \mi{}. However since the \mt{}'s instructions are 
implemented in microcode it could implement a different architecture. This 
document describes a complete implementation of the \ma{}, namely the \mt{}.
\par

The name 'M2' stands for 'Model 2' The 'Model 1' processor was a 4-bit system 
that was constructed by the Author. The Model 1 was implemented in discrete 
hardware, (about 1200 resistors and transistors). The Model 1 is documented 
here: 
\url{https://hackaday.io/project/665-4-bit-computer-built-from-discrete-transistors}
\par

\newpage
\section{Instruction Set}
The \mt{} implements the \mi{}. The \mi{} is a custom instruction set designed for
this project. The instruction set consists of \inum{} instructions that can be 
broadly grouped into four categories: register manipulation, memory access,
arithmetic and logical, and program control.
\par

\subsection{Register Manipulation Instructions}
The register manipulation instructions allow data to be loaded from one
register to another. The Register manipulation instructions allow completely
orthogonal movement of data between general purpose registers (GPRs), 
restricted data movement between special purpose registers (SPRs) and GPRs, 
and no data movement between two SPRs. Most of the \mt{}'s registers are 8-bits
wide, however the addressing registers may be manipulated 16 bits at a time. 
Each GPR serves a multiple purposes. The primary purpose of the GPRs is to 
provide fast data storage for a program. The secondary purpose(s) of each GPR is
as the target or source of data for a given operation. Each SPR serves a single 
purpose. The Data held in an SPR is always interpreted in a consistent manner. 
The following subsections provide a detailed description of each register's 
function:
\par

\subsubsection{A Register}
The \Ar{} register is an 8-bit GPR. The secondary function of the \Ar{} 
register is as the destination of ALU operations. The result of an ALU 
operation is always stored in the \Ar{} register. The designation '\Ar{}' is 
meant to evoke 'accumulator'.
\par

\subsubsection{G Register}
The \Gr{} register is an 8-bit GPR. The \Gr{} register's secondary function is to hold 
the high byte of an address. Some memory instructions are implicitly addressed 
and since the \mt{} supports a 64KB address space addresses are 16-bits wide.
The low byte of an implicit address is stored in the \Hr{} register. Some 
register manipulation instructions act on the \Gr{} register individually while others
treat the combined \Gr{}\Hr{} register as a single 16-bit unit.
\par

\subsubsection{H Register}
The \Hr{} register is an 8-bit GPR. The \Hr{} register's secondary function is as the 
low byte of an implicit address as described in the previous section.
\par

\subsubsection{X Register}
The \Xr{} register is an 8-bit GPR. The \Xr{} register serves two secondary
purposes. The first is as an ALU operand, and the second is as the point of 
access to the Stack Pointer. Since the Stack Pointer is an SPR it's contents
can only be accessed through a GPR, the \Xr{} register is that GPR.
\par

\subsubsection{Y register}
The \Yr{} register is an 8-bit GPR. The \Yr{} register also serves two 
secondary purposes. The first is as the an ALU operand and the second is as
a point of access to the Status register. In general the \Yr{} register serves
a similar purpose as the \Xr{} register.
\par

\subsubsection{Status Register}
The Status Register (\Sr{} register) is an 8-bit SPR. The low four bits of the
\Sr{} register hold the processor's status flags. The status flags are 
automatically manipulated by the ALU after every arithmetic or logical operation
and may also be manipulated by some control instructions. The status flags are
used by the control instructions to control program flow. The contents of the 
\Sr{} register can be accessed through the \Yr{} register. The status flags are:
\begin{itemize}
\item Zero (\texttt{z}, bit 3). Set when the last ALU operation produced zero as
a result
\item Negative (\texttt{n}, bit 2). Set when the result of the last ALU 
operations was negative (as interpreted in two's complement)
\item Carry (\texttt{c}, bit 1). Set when the result of the last ALU operation
produced a '9th bit', i.e. unsigned addition of two numbers greater than 127.
\item Overflow (\texttt{o}, bit 0). Set when the result of the last ALU 
operation produced an impossible result (when interpreted in two's complement)
\end{itemize}
Status flags are positive logic, i.e. set is '1' and clear is '0'.
\par

\subsubsection{Stack Pointer}
The Stack Pointer (\SP{}) is an 8-bit SPR. The \SP{} holds the address of the 
top of the stack. All stack addresses are mapped onto the zeroth page of memory
and can therefore be represented with a single byte. The \SP{} starts at 
address \texttt{0x0000} and is incremented after each push. This means that the 
stack grows from low addresses to high addresses. The value of the \SP{} can be 
accessed through the \Xr{} register.
\par

\subsubsection{Program Counter}
The Program Counter (\PC{}) is a 16-bit SPR. The \PC{} holds the current memory
address. The \PC{} is incremented after each machine cycle so that the next 
instruction can be fetched. Some instructions may load the \PC{} with a value
other than the next instruction. The \PC{} can be accessed through the combined
\Gr{}\Hr{} register.
\par

\subsection{Memory Manipulation Instructions}
Memory manipulation instructions are instructions that move data from memory to a 
register or from a register to memory. No other category of instruction 
manipulates values in memory. There are three types of memory manipulation 
instruction: direct access, literal to register, and stack operations.
\par

\subsubsection{Direct Access}
Direct Access instructions move a single byte from memory to a given GPR or 
from a given GPR to memory. The address of the byte to manipulate is held in 
the combined \Gr{}\Hr{} register. From a machine language perspective direct 
access instructions look like register manipulation instructions with the added
caveat that the value of the '\texttt{M}' register is dependant on the address
held in the \Gr{}\Hr{} register. In general direct access instructions take 
about twice as long as register manipulation instructions.
\par

\subsubsection{Literal to Register}
Literal to register instructions load a single byte literal in to a given GPR.
Literal to register instructions are similar to direct access instructions,
except that no address is required. The byte to be loaded is stored in the
address immediately following the address storing the instruction code. This
means that these instructions take two addresses when assembled.
\par

\subsubsection{Stack Operations}
Stack operations place a byte on the stack (push) or remove a byte from the
stack (pop) and adjust the \SP{} as necessary. Bytes are pushed from or popped
to GPRs. The stack is stored in the first page of memory; addresses 
\texttt{0x0000} to \texttt{0x00FF}. The \SP{} wraps without warning at the edges
of the stack. This means that stack safety is the sole responsibility of the 
programmer. The \mt{} will happily increment the \SP{} from \texttt{0xFF} to
\texttt{0x00} if a byte is pushed to an already full stack without any type of
warning. This unsafe behaviour was implemented to keep stack instruction 
complexity to a minimum. As it stands stack operations are the most complex and
slow instructions in the \mi{}.
\par

\subsection{Arithmetic and Logical Instructions}
Arithmetic and logical instructions preform an artithmetic or logical function
on the \Xr{} and \Yr{} registers, store the result in the \Ar{} register and 
update the flags in the \Sr{} register. The \mt{}'s ALU can calculate 8 
different functions (detailed in section 2.6). Six of these functions require
two inputs (\Xr{} and \Yr{}), and two functions require only one input, (\Xr{}).
\par

\subsection{Program Control Instructions}
Program control instrcutions control the flow of the program. There are four
types of program control instructions: no-operation, unconditional jump,
conditional branch, and status flag manipulation.
\par

As the name suggests the no-operation does nothing. The no-operation is not 
quite a program control instruction, it is more accurately 'the lack of an 
instruction'. The behaviour of the no-operation is well defined so that if a 
program attempts to execute unitialized memory the processor will behave in a 
predictable (and safe) manner. A no-operation takes an entire machine cycle and
one microstate to execute. More information about machine cycles and 
microstates is found in sections 3.3 and 4 respectively.
\par

\subsubsection{Unconditional Jump}
An unconditional jump sets the address of the next instruction to be executed
as the address held in the \Gr{}\Hr{} register. Since the \PC{} is incremented
at the end of every machine cycle  the jump instruction must decrement the \PC{}
after setting it to the value of the \Gr{}\Hr{} register so that the next 
instruction executed is the one held at the address \Gr{}\Hr{}.
\par

\subsubsection{Conditional Branch}
Conditional branch instructions change which instruction is executed next based 
on the value of a status flag. In general conditional branch instructions allow
the next instruction to be executed if some condition is not met. If the 
condition is met the next instruction is skipped and the instruction following 
it is executed next. This means that the two branches differ by exactly one 
instruction. The condition evaluated is the state of one of the status flags
(section 2.1.6). Since there are four status flags, and each can have two 
values (set or clear) there are eight conditional branch instructions, i.e.
branch if flag set, and branch if flag clear. This branching mechanism is
somewhat austere, however it serves to reduce the overall complexity of the
\mt{}.
\par

Some useful assembly language idioms are the 'escape jump' and 'if-else'. Since
two branches may only differ by one instruction it is often useful to make that 
one instruction an unconditional jump. For example:
\lstset{
	basicstyle=\small\ttfamily
}
\begin{lstlisting}
	LDG 0x0A # load the high byte of 
	         # the escape address 0x0AA0
	LDH 0xA0 # load the low byte of 0x0AA0
	BZC # branch if zero is clear
	JMP # executed if zero is set
	LDX A # executed if zero is clear
	.
	.
	.
	# address 0x0AA0
	LDY A # this code only runs if the 
	      # zero flag was set before the branch.
\end{lstlisting}
An 'if-else' statement can be implemented as follows:
\begin{lstlisting}
	LDX 0x10 # put some data in the X 
	         # and Y registers
	LDY 0x01
	BZS
	LDM X # this instruction is executed
	      # if the zero flag is clear
	BZC
	LDM Y # this instruction is executed
	      # if  the zero flag is set
	... 
	# memory is loaded with X if zero is
	# clear, else memory is loaded with Y
\end{lstlisting}
\par

\subsubsection{Status Flag Manipulation}
Status flag manipulation instructions allow the programmer to set the value of
any of the four status flags. There are 8 status flag manipulation instructions
since each flag can be set ('1') or cleared ('0'). The status flag manipulation
instructions are the only way to move data into the \Sr{} register. The 
contents of the \Sr{} register may be dumped into the \Yr{} register. This 
allows status flags to be stored, or inspected by the program.
\par

\newpage
\section{\mt{} Architecture}
This section outlines the modular architecture of the \mt{}. The implementation
of this architecture is described in section 5. The \mt{} is designed (and 
implemented) as a series of modules that communicate over three major busses. 
The way that these modules interact with each other to carry out instructions is
described in the next section (section 4). In general This section describes the 
processor's 'hardware', whereas section 4 describes how this 'hardware' can be 
made to implement an instruction set.
\par

\subsection{Block Diagram}
The architecture of the \mt{} is well described by a block diagram. Figure 1
shows all of the major components of the processor and is organized very 
similarly to the actual VHDL implementation of the \mt{} (section 5). The 
dotted line in figure 1 denotes the boundary of the processor and serves to 
show the seperation between the processor and memory. The dashed arrows denote
single bit control buses (section 4), the light weight arrows denote 8-bit data
and instruction buses, and the medium weight arrows denote 16-bit address buses. 
The heavy weight line denotes the control bus. The bus architecture is 
discussed in further detail in the next section (3.2).
\par

The \mt{}'s internal structure can be loosely divided into two halves; the
processing logic and the control logic. Roughly speaking processing logic is on
the left half of figure 1 and control logic is on the right half. In general 
programs manipulate information with the processing logic. As such the 
functionality of the processing logic is exposed to the programmer through the
instruction set (section 2). The control logic is responsible for actually 
running a program. The primary functions of the control logic are to fetch and 
decode instructions in sequence. Since the operation of the control logic is 
largely invisible to the programmer it is described in detail in section 4.
\par

In an effort to preserve the legability of figure 1 a number of abbreviations
have been used to label the processor's functional blocks. These abbreviations
are described below:
\begin{itemize}
	\item Processing Logic:
	\begin{itemize}
		\item \Ar{}: The \Ar{} register.
		\item \Gr{}, and \Hr{}: The \Gr{} register and \Hr{} register. 
		Note that these registers are grouped. This is reflective of how
		some instructions treat the \Gr{} and \Hr{} registers as a 
		single 16-bit \Gr{}\Hr{} register.
		\item \Xr{}: The \Xr{} register.
		\item \Yr{}: The \Yr{} register.
		\item \Sr{}: The status register.
		\item \SP{}: The stack pointer.
		\item \PC{}: The program counter. Note that the program counter
		is twice as wide a the other registers. This is reflective of 
		the fact that the program counter holds a 16-bit address instead
		of a single byte.
		\item \texttt{ALU}: The arithmetic and logic unit.
	\end{itemize}
	\item Control Logic:
	\begin{itemize}
		\item \texttt{ABM}: Address bus multiplexer
		\item \texttt{DBM}: Data bus multiplexer
		\item \texttt{IR}: Instruction register
		\item \texttt{FSM}: Finite state machine
		\item \texttt{CBEN}: Control bus enable
		\item \texttt{MICROCODE}: The microcode look up table
		\item \texttt{DECODE}: Branch decoding logic
	\end{itemize}
	\item \texttt{RST} and \texttt{CLK}: The processor's reset and clock 
	lines respectively.
\end{itemize}
A detailed description of each functional block and how it maps to actual VHDL 
is given in section 5.
\par

\newpage
\thispagestyle{empty}
\begin{landscape}
	\begin{figure}
	\makebox[\linewidth]{
		\includegraphics[
			width=18cm,
			height=18cm,
			keepaspectratio
		]{M2CPU_architecture_diagram.png}
	}
	\caption{Simplified \mt{} Block Diagram}
	\end{figure}
\end{landscape}

\newpage
\subsection{Bus Architecture}
The \mt{} is designed around 3 major buses; the 8-bit data bus, the 16-bit 
address bus and the \ibusnum{}-bit control bus. The data bus is used to move 
data around the processor. Bytes on the data bus are never interpreted as 
instructions, however instructions can be placed on the data bus if the 
programmer desires. The address bus is used to move addresses around the 
processor. The processor's 8-bit data buses are strictly seperated from the 
16-bit address buses. The only points of access between the 16-bit bus and the 
8-bit bus are the stack pointer and the combined \Gr{}\Hr{} register. The 
control bus is the collection of control signals coming from the processing 
logic. The control bus is made up of load, increment, and select lines. The 
implementation of the \mt{}'s bus architecture is described in section 5.
\par

\newpage
\section{Control Logic}
The control logic is responsible for manipulating the processing logic in such
a way that an instruction is carried out. For any given instruction a variety
of low level operations must be carried out. The instruction must be fetched
from a memory address, it must be decoded, control signals must be applied to
the control bus for specific lenghts of time, and finally the address of the
next instruction must be calculated. This general sequence of operations is the
machine cycle. The specifics of the \mt{}'s machine cycle are discussed in the 
next section (4.1).
\par

For each instruction some stages of the machine cycle are the same. All 
instructions must be fetched and decoded, and the address of the next 
instruction must be determined before the next machine cycle can begin. However
every instrcution does a different thing. In the \mt{} the stages of the 
machine cycle that differ for each instruction are written in microcode. This
means that some portion of each machine cycle is spent executing instruction
specific microcode rather than instruction agnostic machine states.
\par

Some instructions take more time to execute than others. This means that the 
machine cycle for one instruction may have a different number of microcode 
steps than the machine cycle for another. The \mt{} allows an arbitrary number
of microcode steps to be executed for each instruction. This is one of the few
optimizations made in the \ma{}. This optimization was deemed necessary since
some instructions in the \mi{} differ in execution time by 300\%. If this
optimization was not made and the \mt{} had a fixed length machine cycle the
fastest (and most used) instructions would leave the processor idle for around
two thirds of its execution time.
\par

\subsection{Machine Cycle}
The machine cycle is the series of steps that are carried out to execute an
instruction. In the \mt{} the machine cycle is controlled by a finite state 
machine (FSM). A state diagram for the \mt{}'s FSM is shown in figure 2. The
FSM has six states. Transitions between states occur on the rising edge of the
system clock. To accomodate a variable number of microcode steps the \mt{} may
remain in the \Ex{} state for an arbitrary number of clock cycles. 
\par

\begin{wrapfigure}{R}{0.5\textwidth}
\includegraphics[
	width=13cm,
	height=13cm,
	keepaspectratio
]{M2CPU_FSM.png}
\caption{\mt{} Finite State Machine State Diagram}
\end{wrapfigure}

The processor resets to the \Se{} state, as such \Se{} is the first state in 
the machine cycle. In the \Se{} state the value held in the program counter is
placed on the address bus (via the ABM, section 3.2). Additionally the control
bus is set to zero (via the CBEN). This state ensures that the address of the
next instruction to execute is placed on the address bus and is not changing by
the time memory access starts. This state sets up the address so that memory
access can begin.
\par

The second and third states in the machine cycle (\Fo{} and \Ft{}) allow time 
for the next instruction to be retrieved from memory. Memory requires two clock
cycles to access, one to latch the address in and one to latch data out. Since
the program counter's value cannot be gauranteed until the end of \Se{}, two
additional states are required to ensure that memory is accessed properly. The
current memory value is an input to the DBM (section 3.1 \& 3.2) and the input
to the instruction register (\IR{}). During the \Ft{} state the load line on
the \IR{} is asserted.
\par

The fourth state \Lo{}, loads the \IR{}. During the \Lo{} state the control bus
is disabled and the program counter is applied to the address bus. This ensures
that the FSM is still in control of the processor. At this point in the machine
cycle the processor has loaded a new instruction and is ready to begin 
executing it. 
\par

On the next clock edge the control bus is enabled, thereby passing control to
the microcode. This is the \Ex{} state. Each 'microinstruction' that is 
executed represents an instruction specific 'microstate' that the processor
enters while remaining in the \Ex{} 'macrostate'. Each microinstruction that is
followed by another microinstruction must signal the FSM to ensure that it 
remains in the \Ex{} 'macrostate'. The last microintruction in an instruction 
does not signal the FSM, thereby allowing it to continue to the final state in
the machine cycle.
\par

The sixth and final state in the \mt{}'s mchine cycle is \In{} state. In the 
\In{} state the control bus is set to 0, passing control back to the FSM, and 
the program counter is incremented. The processor is now ready to begin 
fetching the next instruction in the program.
\par

\subsection{Microcode}
The \mt{}'s microcode provides a means to translate an instruction into a 
control bus state. The \mt{}' microcode is stored in a look up table. The
instrcution held in the \IR{} acts as an address and is fed into the look up
table. The output of the look up table is applied to the control bus enable
multiplexer (CBEN in figure 1). When in the \Ex{} state the CBEN is set to
apply the microcode to the control bus. Every microinstruction that is followed
by another microinstruction must signal the FSM to remain in the \Ex{} state.
This means that the last microinstruction in a 'microprogram' 
(macroinstruction) must not signal the FSM, thereby allowing the machine cycle
to continue. Additionally each microinstrution must load the next 
microinstruction in the 'microprogram'.
\par

The contents of the \IR{} act as a 'microaddress' for the 'microprogram' that
implements an instruction. As such the \IR{}'s value must be changed in order
to address a new microinstruction. It makes sense to store microinstructions
in sequential microaddresses as this allows the next microinstruction in a
microprogram to be indexed simply by incrementing the value of the \IR{}. This
is exactly how the \mt{} works. The \IR{} includes logic to allow it to be 
incremented and thereby index the next microinstruction. Since the condition
for signaling the FSM to stay in the \Ex{} state and the condition for
incrementing the \IR{} are the same a single bit of the control bus can be used
to do both.
\par

A downside of incrementing the \IR{} to index a new microinstruction is that 
some instruction codes cannot be used. If a given instruction \textit{C} 
requires three microstates to complete then the \IR{} must be incremented twice
after being loaded with the code representing \textit{C}. This means that the
values \textit{C}, \textit{C} + 1, and \textit{C} + 2, are all addresses in the
same microprogram. Therefore no other instruction may be represented with the
codes \textit{C} + 1 or \textit{C} + 2. When an macroinstruction is said to be
represented by a given opcode \textit{C} what is really meant is that the 
opcode \textit{C} is the first microaddress in the microprogram that implements
that macroinstruction. Table 1 shows which opcode each instruction in the \mi{}
maps to. The shaded cells in table 1 are microaddresses which are only steps
in microprograms. The labeled cells are the first addresses in their respective
microprograms, i.e. 'the opcode' for that instruction.
\par

%TODO shade cells. add section on decoder

\newpage
\section{VHDL Implementation}
make a section for each file and describe what it is on fig 1
\subsection{Bus Architecture Implementation}
Buses are often represented as strictly passive, i.e. wires. This presents a 
problem when multiple logical outputs are attached to a single bus: suppose one
device whishes to assert a value on the bus, what value should the other 
devices on the bus assert? In discrete logic this problem is often resolved with
tri-state logic. While tri-state logic can be modeled in VHDL it is awkward to 
do so. As such The \mt{}'s implementation avoids this issue by implementing 
buses as multiplexers. For example; all devices that can assert data to the data
bus are attached to the inputs of a data bus multiplexer (DBM). The output of 
the DBM is then attached to the input of every device that reads from the data 
bus.
\par

\newpage
\section{Detailed Instruction Descriptions}
This section provides a detailed description of each instruction in the \mi{}.
Some instructions are very similar, as such they have been grouped for 
convenience. A discription of each instruction's microstates is also included.
This section is included primarily as technical reference. High level 
descriptions of the instruction set and the microcode implementation are provided
in sections 2 and 4 respectively. Table 1 (section 6.14) provides a handy 
programming reference.
\par
\subsection{Load GPR}
\subsection{Load SPR}
\subsection{Load Memory From GPR}
\subsection{Load GPR From Memory}
\subsection{Load GPR With Literal}
\subsection{Push GPR}
\subsection{Pop GPR}
\subsection{ALU Operations}
\subsection{Set Status Flag}
\subsection{Clear Status Flag}
\subsection{Conditional Branch}
\subsection{No-operation}
\subsection{Jump}
\subsection{Instruction Table}
Table 1 shows each instruction and its corresponding hexadecimal code. Each
instruction is a single byte long, some instructions take a single byte-literal 
argument represented with a '\texttt{\#}'. The hexadecimal code (microaddress) 
for a a given instruction is found by adding the high nybble (row) and low 
nybble (column). Detailed descriptions each instruction are provided in 
sections 6.1 to 6.13.
\par

\newpage
\thispagestyle{empty}
\begin{landscape}
\begin{table}
	\makebox[\linewidth]{
		\texttt{
		\begin{tabular}{ c c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
			\cline{3-18}
			&&\multicolumn{16}{|c|}{LOW NYBBLE} \\ 
			\cline{3-18}
			&&0x00&0x01&0x02&0x03&0x04&0x05&0x06&0x07&0x08&0x09&0x0A&0x0B&0x0C&0x0D&0x0E&0x0F \\ \hline
			\multicolumn{1}{|c|}{}&0x00&NOP&LDA G&&LDA H&&LDA X&&LDA Y&&LDSP X&&&ADD&&BZS& \\ \cline{2-18}
			\multicolumn{1}{|c|}{}&0x10&&LDG A&&LDG H&&LDG X&&LDG Y&&LDX SP&&&SUB&&BZC& \\ \cline{2-18}
			\multicolumn{1}{|c|}{H}&0x20&&LDH A&&LDH G&&LDH X&&LDH Y&&LDY S&&&AND&&BNS& \\ \cline{2-18}
			\multicolumn{1}{|c|}{I}&0x30&&LDX A&&LDX G&&LDX H&&LDX Y&&LDGH PC&&&NND&&BNC& \\ \cline{2-18}
			\multicolumn{1}{|c|}{G}&0x40&&LDY A&&LDY G&&LDY H&&LDY X&&JMP&&&ORR&&BCS& \\ \cline{2-18}
			\multicolumn{1}{|c|}{H}&0x50&&&&&&&&&&&&&XOR&&BCC& \\ \cline{2-18}
			\multicolumn{1}{|c|}{}&0x60&LDM A&&&LDA M&&&&LDA \#&&&&&STL&&BOS& \\ \cline{2-18}
			\multicolumn{1}{|c|}{N}&0x70&LDM G&&&LDG M&&&&LDG \#&&&&&STR&&BOC& \\ \cline{2-18}
			\multicolumn{1}{|c|}{Y}&0x80&LDM H&&&LDH M&&&&LDH \#&&&&&&&SZF& \\ \cline{2-18}
			\multicolumn{1}{|c|}{B}&0x90&LDM X&&&LDX M&&&&LDX \#&&&&&&&CZF& \\ \cline{2-18}
			\multicolumn{1}{|c|}{B}&0xA0&LDM Y&&&LDY M&&&&LDY \#&&&&&&&SNF& \\ \cline{2-18}
			\multicolumn{1}{|c|}{L}&0xB0&PHA&&&&&PPA&&&&&&&&&CNF& \\ \cline{2-18}
			\multicolumn{1}{|c|}{E}&0xC0&PHG&&&&&PPG&&&&&&&&&SCF& \\ \cline{2-18}
			\multicolumn{1}{|c|}{}&0xD0&PHH&&&&&PPH&&&&&&&&&CCF& \\ \cline{2-18}
			\multicolumn{1}{|c|}{}&0xE0&PHX&&&&&PPX&&&&&&&&&SOF& \\ \cline{2-18}
			\multicolumn{1}{|c|}{}&0xF0&PHY&&&&&PPY&&&&&&&&&COF& \\ \hline
		\end{tabular}
		}
	}
	\caption{The M2 Instruction Set}
\end{table}
\end{landscape}

\newpage
\section{Conclusion}

\end{document}
